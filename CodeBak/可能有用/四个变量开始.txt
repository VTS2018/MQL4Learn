//+------------------------------------------------------------------+
//| ✅ 四个变量开始 将来可能会移除掉 调试控制
//+------------------------------------------------------------------+
// extern bool Debug_Print_Info_Once = true; // 是否仅在指标首次加载时打印调试信息 (如矩形范围等)
// static bool initial_debug_prints_done = false; // 内部标志：是否已完成首次加载时的调试打印

// extern bool Debug_LimitCalculations = true; // 限制运行次数 用于开发调试阶段
// static int g_run_count = 0; // 记录 OnCalculate 的运行次数


    /** 如果将来调试代码，就将这里的注释去掉，让代码进入到Tick的执行模式 并开启上面的四个变量
    if (Debug_LimitCalculations)
    {
        if (g_run_count >= 3)
        {
            // 如果达到限制，阻止进一步计算，直接返回
            return (rates_total);
        }
        g_run_count++; // 每次运行时增加计数
        // 打印提示信息到日志，便于调试确认
        Print("DEBUG LIMIT: OnCalculate Run #", g_run_count, " of 3");
    }

    // 检查是否有 K 线存在
    if(rates_total < 1) return(0); 

    // 清除缓冲区中的所有旧标记
    ArrayInitialize(BullishTargetBuffer, EMPTY_VALUE);
    ArrayInitialize(BearishTargetBuffer, EMPTY_VALUE);
    ArrayInitialize(BullishSignalBuffer, EMPTY_VALUE);
    ArrayInitialize(BearishSignalBuffer, EMPTY_VALUE);
    
    // 寻找并绘制所有符合条件的 K-Target 及突破信号
    FindAndDrawTargetCandles(rates_total);

    // [V1.25 NEW] 在第一次完整计算完成后，设置标志位，确保后续的 tick 不再触发调试打印。
    if (rates_total > prev_calculated) // 检查是否有新数据
    {
         if (!initial_debug_prints_done)
         {
              initial_debug_prints_done = true;
         }
    }
    
    // 返回 rates_total 用于下一次调用
    return(rates_total);
    */