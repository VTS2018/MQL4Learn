#property indicator_chart_window  // 告诉 MT4 这个指标是画在主图上的（和 K 线在一起），而不是副图指标
#property indicator_buffers 1     // 告诉 MT4 只需要“画” 1 条线（虽然内部用了3个数组，但只有1个是给用户看的）
#property indicator_color1  Red   // 设置第 1 条线（也就是 ZigZag 线）的默认颜色为红色

input int InpDepth=12;       // Depth (深度): 寻找高低点时，往前扫描的 K 线数量范围
input int InpDeviation=5;    // Deviation (偏差): 只有当价格回撤超过 5 个微点(Points)时，才考虑由于产生新拐点
input int InpBackstep=3;     // Backstep (回退): 两个拐点之间至少要隔多少根 K 线

double ExtZigzagBuffer[]; // 【核心显示数组】存储最终确定的 ZigZag 拐点价格 (Buffer 0)
double ExtHighBuffer[];   // 【内部计算数组】存储候选的“高点” (Buffer 1, 不画图)
double ExtLowBuffer[];    // 【内部计算数组】存储候选的“低点” (Buffer 2, 不画图)

int OnInit()
{
   // 1. 逻辑自检：如果回退步长 >= 扫描深度，逻辑会死循环或错误，直接报错停止
   if(InpBackstep >= InpDepth)
   {
      Print("Backstep cannot be greater or equal to Depth");
      return(INIT_FAILED);
   }

   // 2. 关键黑魔法：IndicatorBuffers(3)
   // 虽然上面 #property indicator_buffers 写的是 1，但这里告诉 MT4：“我实际需要 3 个缓冲区”。
   // 只有第 0 个会显示出来，第 1 和 2 个是用来在内存里存中间数据的（高低点候选）。
   IndicatorBuffers(3);

   // 3. 设置绘图风格
   // DRAW_SECTION 的意思是：数组里大部分是 0（空值），只有偶尔有值。
   // MT4 会自动把这些稀疏的点用直线连起来。这就是 ZigZag 这种折线的画法。
   SetIndexStyle(0, DRAW_SECTION);

   // 4. 绑定数组到缓冲区索引
   SetIndexBuffer(0, ExtZigzagBuffer); // Index 0 -> 画出来的红线
   SetIndexBuffer(1, ExtHighBuffer);   // Index 1 -> 存高点候选
   SetIndexBuffer(2, ExtLowBuffer);    // Index 2 -> 存低点候选

   // 5. 设置空值
   // 告诉 MT4，如果数组里的值是 0.0，就不要画出来（当做没数据）。
   SetIndexEmptyValue(0, 0.0);

   return(INIT_SUCCEEDED);
}
-------------------------------------------------------------------------------------------------------------------------------
//+------------------------------------------------------------------+
//| 核心计算函数：每当有新报价时触发
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long& tick_volume[],
                const long& volume[],
                const int& spread[])
  {
   // 定义局部变量
   int    i, limit, counterZ, whatlookfor=0;
   int    back, pos, lasthighpos=0, lastlowpos=0;
   double extremum;
   double curlow=0.0, curhigh=0.0, lasthigh=0.0, lastlow=0.0;

   // --- 1. 数据量检查 ---
   // 如果当前K线总数少于搜索深度(Depth)，或者回退步长(Backstep)设置错误，无法计算，直接返回0
   if(rates_total < InpDepth || InpBackstep >= InpDepth)
      return(0);

   // --- 2. 确定计算范围 (limit) ---
   
   // 情况A：首次计算 (prev_calculated 为 0)
   if(prev_calculated == 0)
      limit = InitializeAll(); // 初始化所有缓冲区，并从最左边开始算
   
   // 情况B：增量计算 (有新K线生成)
   else 
     {
      // ZigZag 的特性：最新的价格变化可能会改变之前的拐点
      // 所以我们不能只算最新的一根，必须回溯去找之前的锚点
      
      // 目标：找到过去第 3 个 (ExtLevel) 已经确定的拐点
      i = counterZ = 0;
      while(counterZ < ExtLevel && i < 100) // 最多回溯100根K线，或者找到3个拐点为止
        {
         if(ExtZigzagBuffer[i] != 0.0) // 这里的 i 是从 0 (最新) 开始往历史走的索引吗？
            counterZ++;                // 注意：MT4 默认指标数组通常索引 0 是最新。
                                       // 但 ZigZag 这里的逻辑有点特殊，它其实是在寻找重算的起始锚点。
         i++;
        }
      
      // 如果找了100根都没找到足够的拐点 (极少见，除非刚开始)
      if(counterZ == 0)
         limit = InitializeAll(); // 重头算
      else
        {
         // 找到了锚点，把计算起始位置定在这里
         limit = i - 1;
         
         // 确定当前的“状态”：上一个锚点是高点还是低点？
         if(ExtLowBuffer[i] != 0.0) 
           {
            // 如果锚点是低点，保存它的值
            curlow = ExtLowBuffer[i];
            // 状态机：下一个我们需要找高点
            whatlookfor = 1;
           }
         else
           {
            // 如果锚点是高点，保存它的值
            curhigh = ExtHighBuffer[i];
            // 状态机：下一个我们需要找低点
            whatlookfor = -1;
           }
         
         // --- 关键操作：清除脏数据 ---
         // 从锚点开始到最新的K线，把之前计算过的临时结果全部清空
         // 因为我们要重新评估这段区域的趋势
         for(i = limit - 1; i >= 0; i--)  
           {
            ExtZigzagBuffer[i] = 0.0; // 清空显示线
            ExtLowBuffer[i] = 0.0;    // 清空临时低点
            ExtHighBuffer[i] = 0.0;   // 清空临时高点
           }
        }
     }

   // --- 3. 第一轮循环：寻找“候选”高低点 ---
   // 从 limit (历史) 向 0 (最新) 遍历
   for(i = limit; i >= 0; i--)
     {
      // --- A. 寻找区间最低点 ---
      // 在 i 到 i+Depth 的范围内寻找最低价的位置，并获取该价格
      extremum = low[iLowest(NULL, 0, MODE_LOW, InpDepth, i)];
      
      // 如果找到的这个最低价和上一次记录的一样，说明还在同一个底部区域，忽略
      if(extremum == lastlow)
         extremum = 0.0;
      else 
        { 
         // 发现了新的潜在低点值
         lastlow = extremum;
         
         // 偏差过滤 (Deviation)：
         // 如果当前K线的低点(low[i]) 比 找到的区间最低价(extremum) 高出太多
         // 说明 low[i] 根本不是那个最低点的位置（极值点在 Depth 范围内的其他地方）
         // 这里的逻辑其实是确认：当前 K 线 i 是否就是那个极值点？
         if(low[i] - extremum > InpDeviation * Point)
            extremum = 0.0;
         else
           {
            // 回退过滤 (Backstep)：
            // 如果确认了这是一个新的更低的低点，我们需要检查它前面几根(Backstep)K线
            // 如果前面已经标记过一个低点，但比现在这个高（也就是伪低点），把它删掉
            for(back = 1; back <= InpBackstep; back++)
              {
               pos = i + back;
               if(ExtLowBuffer[pos] != 0 && ExtLowBuffer[pos] > extremum)
                  ExtLowBuffer[pos] = 0.0; // 删掉旧的伪低点
              }
           }
        } 
      
      // 如果当前K线 i 真的是那个极值点，写入候选缓冲区
      if(low[i] == extremum)
         ExtLowBuffer[i] = extremum;
      else
         ExtLowBuffer[i] = 0.0;

      // --- B. 寻找区间最高点 ---
      // 逻辑同上，方向相反
      extremum = high[iHighest(NULL, 0, MODE_HIGH, InpDepth, i)];
      
      if(extremum == lasthigh)
         extremum = 0.0;
      else 
        {
         lasthigh = extremum;
         // 偏差过滤：当前高点必须足够接近区间最高价
         if(extremum - high[i] > InpDeviation * Point)
            extremum = 0.0;
         else
           {
            // 回退过滤：如果有更高的高点出现，删除前面 Backstep 范围内的伪高点
            for(back = 1; back <= InpBackstep; back++)
              {
               pos = i + back;
               if(ExtHighBuffer[pos] != 0 && ExtHighBuffer[pos] < extremum)
                  ExtHighBuffer[pos] = 0.0; // 删掉旧的伪高点
              } 
           }
        }
      
      // 写入候选缓冲区
      if(high[i] == extremum)
         ExtHighBuffer[i] = extremum;
      else
         ExtHighBuffer[i] = 0.0;
     }

   // --- 4. 第二轮循环：最终确认连线 ---
   // 现在的 ExtHighBuffer 和 ExtLowBuffer 里有很多候选点
   // 这一步要确定“高-低-高-低”的严格交替顺序
   
   // 恢复状态机初始状态
   if(whatlookfor == 0)
     {
      lastlow = 0.0;
      lasthigh = 0.0;
     }
   else
     {
      lastlow = curlow;
      lasthigh = curhigh;
     }

   for(i = limit; i >= 0; i--)
     {
      switch(whatlookfor)
        {
         case 0: // 初始状态：还没确定其实是高还是低，谁先出现算谁的
            if(lastlow == 0.0 && lasthigh == 0.0)
              {
               if(ExtHighBuffer[i] != 0.0)
                 {
                  lasthigh = High[i];
                  lasthighpos = i;
                  whatlookfor = -1; // 找到了高点，下一步找低点
                  ExtZigzagBuffer[i] = lasthigh; // 【最终画图】
                 }
               if(ExtLowBuffer[i] != 0.0)
                 {
                  lastlow = Low[i];
                  lastlowpos = i;
                  whatlookfor = 1; // 找到了低点，下一步找高点
                  ExtZigzagBuffer[i] = lastlow; // 【最终画图】
                 }
              }
             break;

         case 1: // 正在找高点 (Look for peak)
            // 意外情况：在找高点的路上，又遇到了一个比上一次低点还低的低点？
            if(ExtLowBuffer[i] != 0.0 && ExtLowBuffer[i] < lastlow && ExtHighBuffer[i] == 0.0)
              {
               // 说明上一次那个低点是假的（半山腰），删掉它！
               ExtZigzagBuffer[lastlowpos] = 0.0; 
               // 更新为这个更低的低点
               lastlowpos = i;
               lastlow = ExtLowBuffer[i];
               ExtZigzagBuffer[i] = lastlow;
              }
            // 正常情况：找到了高点
            if(ExtHighBuffer[i] != 0.0 && ExtLowBuffer[i] == 0.0)
              {
               lasthigh = ExtHighBuffer[i];
               lasthighpos = i;
               ExtZigzagBuffer[i] = lasthigh; // 确认为高点
               whatlookfor = -1; // 状态切换：下一步找低点
              }   
            break;

         case -1: // 正在找低点 (Look for lawn)
            // 意外情况：在找低点的路上，又遇到了一个比上一次高点还高的高点？
            if(ExtHighBuffer[i] != 0.0 && ExtHighBuffer[i] > lasthigh && ExtLowBuffer[i] == 0.0)
              {
               // 说明上一次那个高点是假的，删掉它！
               ExtZigzagBuffer[lasthighpos] = 0.0;
               // 更新为这个更高的高点
               lasthighpos = i;
               lasthigh = ExtHighBuffer[i];
               ExtZigzagBuffer[i] = lasthigh;
              }
            // 正常情况：找到了低点
            if(ExtLowBuffer[i] != 0.0 && ExtHighBuffer[i] == 0.0)
              {
               lastlow = ExtLowBuffer[i];
               lastlowpos = i;
               ExtZigzagBuffer[i] = lastlow; // 确认为低点
               whatlookfor = 1; // 状态切换：下一步找高点
              }   
            break;
        }
     }

   // 返回本次计算的总K线数，作为下一次调用的 prev_calculated
   return(rates_total);
  }