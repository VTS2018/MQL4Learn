//+------------------------------------------------------------------+
//| 辅助函数：合并看涨和看跌列表，并按 shift 从小到大 (由新到旧) 排序  |
//+------------------------------------------------------------------+
void MergeAndSortSignals(FilteredSignal &bulls[], FilteredSignal &bears[], FilteredSignal &result_list[])
{
    int size_bull = ArraySize(bulls);
    int size_bear = ArraySize(bears);
    int total_size = size_bull + size_bear;

    // 1. 重置结果数组大小
    ArrayResize(result_list, total_size);

    // 2. 合并数据
    int index = 0;
    // 先放入看涨信号
    for (int i = 0; i < size_bull; i++)
    {
        result_list[index] = bulls[i];
        index++;
    }
    // 再放入看跌信号
    for (int i = 0; i < size_bear; i++)
    {
        result_list[index] = bears[i];
        index++;
    }

    // 3. 排序 (冒泡排序 Bubble Sort)
    // 目标：按 shift 值从小到大排序 (shift 1 是最新，shift 100 是较旧)
    // 这样循环时，我们总是先处理离现价最近的有效信号
    if (total_size > 1)
    {
        for (int i = 0; i < total_size - 1; i++)
        {
            for (int j = 0; j < total_size - i - 1; j++)
            {
                // 如果前一个信号的 shift 比后一个大 (说明前一个更旧)，则交换
                if (result_list[j].shift > result_list[j + 1].shift)
                {
                    FilteredSignal temp = result_list[j];
                    result_list[j] = result_list[j + 1];
                    result_list[j + 1] = temp;
                }
            }
        }
    }
}