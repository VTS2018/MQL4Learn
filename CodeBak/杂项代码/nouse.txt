//+------------------------------------------------------------------+
//| 函数: 寻找最近的结构性止损 (锚点价格)
//| buffer_index: 0=看涨锚点, 1=看跌锚点
//+------------------------------------------------------------------+
/*
double FindStructuralSL_v1(int buffer_index, int start_shift)
{
   // 向左回溯查找最近的一个锚点
   // 限制回溯 Scan_Range 根，避免死循环
   for(int i = start_shift; i < start_shift + Indi_Scan_Range; i++)
   {
      double val = GetIndicatorSignal(buffer_index, i);
      
      if(val != (double)EMPTY_VALUE && val != 0)
      {
         // 找到了！
         // Buffer 0 存的是 Low - 偏移，Buffer 1 存的是 High + 偏移
         // 为了精确，我们直接取那一根K线的 Low 或 High
         if(buffer_index == 0) return Low[i];  // 看涨结构低点
         if(buffer_index == 1) return High[i]; // 看跌结构高点
      }
   }
   return 0; // 未找到
}
*/

/*
// KTarget_FinderBot.mq4 (兼容 Bot 1.0 架构的修正)

double FindStructuralSL(int buffer_index, int start_shift)
{
    // 确定要读取的 SL 价格缓冲区和信号质量缓冲区
    int sl_price_buffer = buffer_index;      // 0 或 1
    int quality_buffer = buffer_index + 2;   // 2 或 3

    // 限制回溯 Scan_Range 根
    for(int i = start_shift; i < start_shift + Indi_Scan_Range; i++)
    {
        // 1. 读取信号质量 (Buffer 2 或 Buffer 3)
        // val 现在代表信号质量代码 (3.0, 2.0, 或 EMPTY_VALUE)
        double signal_quality = GetIndicatorSignal(quality_buffer, i); 
        
        // 2. 检查信号是否存在 (即质量代码已写入)
        if (signal_quality != (double)EMPTY_VALUE && signal_quality >= 2.0) // 假设我们只关心 P2 和 P1-DB 信号 (2.0/3.0)
        {
            // 3. 信号存在！现在读取已计算好的 SL 绝对价格 (Buffer 0 或 Buffer 1)
            double sl_price = GetIndicatorSignal(sl_price_buffer, i);
            
            // 4. 检查 SL 价格是否有效 (必须大于 0.0)
            if (sl_price != (double)EMPTY_VALUE && sl_price != 0.0)
            {
                // 找到了！返回绝对 SL 价格
                return sl_price; 
            }
        }
    }
    
    return 0.0; // 未找到有效的 SL 价格
}
*/