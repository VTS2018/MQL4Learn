//+------------------------------------------------------------------+
//| ScanForTradeSignal_v3 (ä¿®å¤ç‰ˆ)
//| åŠŸèƒ½ï¼šv3 å¼•æ“çš„ä¿¡å·æ‰«æå™¨ (é€‚é…å™¨æ¨¡å¼)
//| ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨æœ¬åœ° sl å˜é‡ï¼Œè§£å†³ struct member undefined é”™è¯¯
//+------------------------------------------------------------------+
void ScanForTradeSignal_v3()
{
    // 1. å§‹ç»ˆåªæ‰«æåˆšåˆšæ”¶ç›˜çš„ K çº¿ (Shift 1)
    int shift = 1;
    
    // å‡è®¾å‘å‰å›æº¯ 60 æ ¹ K çº¿å¯»æ‰¾ç»“æ„
    int search_depth = 60; 

    // =============================================================
    // A. æ‰«æåšå¤šä¿¡å· (Bullish)
    // =============================================================
    for (int i = shift + 1; i < shift + search_depth; i++)
    {
        // 1. è°ƒç”¨ä¸»æ–‡ä»¶çš„æ‰¾åº•å‡½æ•°
        if (CheckKTargetBottomCondition(i, Bars)) 
        {
            double p1 = Open[i];
            
            // 2. ç®€å•çš„ P2 æŸ¥æ‰¾
            double p2 = 0;
            for(int k=1; k<50; k++) { if(Close[i+k] > Open[i+k]) { p2=Close[i+k]; break; } }
            if(p2==0) p2 = p1 * 1.001; // å®¹é”™
            
            // âœ… [é‡ç‚¹] æ­¢æŸä»·åœ¨è¿™é‡Œå·²ç»è®¡ç®—å¥½äº†
            double sl = Low[i]; 

            // 3. æ£€æŸ¥ shift=1 æ˜¯å¦è§¦å‘äº†çªç ´
            bool is_breakout = (Close[shift] > p1); 

            if (is_breakout)
            {
                // 4. è°ƒç”¨ v3 å†…æ ¸è¯„åˆ†
                SignalQuality sq = EvaluateSignal(Symbol(), Period(), i, shift, p1, p2, sl, true);
                
                // 5. å†³ç­–
                if (sq.grade >= Min_Trade_Grade && sq.space_factor >= Min_Space_Factor)
                {
                    // === é€‚é…å™¨æ„é€  ===
                    KBarSignal adapter_data;
                    adapter_data.OpenTime = Time[shift];
                    
                    // ğŸš¨ [ä¿®å¤ç‚¹ 1] ç›´æ¥ä½¿ç”¨æœ¬åœ°å˜é‡ slï¼Œè€Œä¸æ˜¯ sq.sl_price
                    adapter_data.BullishStopLossPrice = sl; 
                    
                    // å€Ÿç”¨ ReferencePrice å­˜å‚¨è¯„çº§
                    adapter_data.BullishReferencePrice = (double)sq.grade; 
                    
                    adapter_data.BearishStopLossPrice = 0;
                    adapter_data.BearishReferencePrice = 0;

                    Print("ğŸ”¥ v3 å¼•æ“è§¦å‘åšå¤š! è¯„çº§:", sq.description, " SL:", sl); // è¿™é‡Œä¹Ÿæ‰“å° sl

                    CalculateTradeAndExecute_V2(adapter_data, OP_BUY);
                    return; 
                }
            }
        }
    }

    // =============================================================
    // B. æ‰«æåšç©ºä¿¡å· (Bearish)
    // =============================================================
    for (int i = shift + 1; i < shift + search_depth; i++)
    {
        if (CheckKTargetTopCondition(i, Bars)) 
        {
            double p1 = Open[i];
            double p2 = 0;
            for(int k=1; k<50; k++) { if(Close[i+k] < Open[i+k]) { p2=Close[i+k]; break; } }
            if(p2==0) p2 = p1 * 0.999;
            
            // âœ… [é‡ç‚¹] æ­¢æŸä»·åœ¨è¿™é‡Œè®¡ç®—å¥½äº†
            double sl = High[i];
            
            if (Close[shift] < p1) // çªç ´ P1
            {
                SignalQuality sq = EvaluateSignal(Symbol(), Period(), i, shift, p1, p2, sl, false);
                
                if (sq.grade >= Min_Trade_Grade && sq.space_factor >= Min_Space_Factor)
                {
                    KBarSignal adapter_data;
                    adapter_data.OpenTime = Time[shift];
                    
                    // ğŸš¨ [ä¿®å¤ç‚¹ 2] ç›´æ¥ä½¿ç”¨æœ¬åœ°å˜é‡ sl
                    adapter_data.BearishStopLossPrice = sl;
                    
                    adapter_data.BearishReferencePrice = (double)sq.grade;
                    
                    adapter_data.BullishStopLossPrice = 0;
                    adapter_data.BullishReferencePrice = 0;

                    Print("â„ï¸ v3 å¼•æ“è§¦å‘åšç©º! è¯„çº§:", sq.description, " SL:", sl);

                    CalculateTradeAndExecute_V2(adapter_data, OP_SELL);
                    return;
                }
            }
        }
    }
}