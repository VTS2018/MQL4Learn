//+------------------------------------------------------------------+
//| 💰 风控计算模块
//+------------------------------------------------------------------+
double CalculateRiskLotSize(double sl_price, double entry_price)
{
   // --- 第一步：确定愿意亏损多少钱 (Risk Money) ---
   // 根据全局变量 Risk_Mode 判断：
   // 如果是 RISK_FIXED_MONEY (固定金额模式)，直接使用 Risk_Value (例如 100 美元)
   // 如果是 RISK_PERCENTAGE (百分比模式)，计算账户余额的百分比 (例如 余额 * 1%)
   double risk_money = (Risk_Mode == RISK_FIXED_MONEY) ?
      Risk_Value : AccountBalance() * (Risk_Value / 100.0);

   // --- 第二步：计算止损距离 (Distance in Points) ---
   // MathAbs 取绝对值，确保结果为正数 (不管做多做空)
   // 除以 Point 是为了将价格差转换为 MT4 的微点数 (Points)
   double dist_points = MathAbs(entry_price - sl_price) / Point;

   // --- 第三步：获取市场数据 (Market Info) ---
   // 获取当前品种每跳动一次的价值 (以账户货币计，例如 1手波动1点值多少钱)
   double tick_value = MarketInfo(Symbol(), MODE_TICKVALUE); 
   // 获取当前品种的最小跳动单位 (Tick Size)
   double tick_size  = MarketInfo(Symbol(), MODE_TICKSIZE);

   // 防御性编程：防止分母为 0 导致除零错误
   if (tick_size == 0) tick_size = Point; 

   // --- 第四步：计算标准手亏损额 (Loss Per Standard Lot) ---
   // 公式含义：(止损点数 * 单点价值系数) = 1手单子在止损距离下的总亏损额
   // 例如：止损 500 点，1手每点值 $1，则 1手亏损 $500
   double loss_per_lot = (dist_points * Point / tick_size) * tick_value;

   // 防御性编程：如果计算出的亏损额异常 (<=0)，说明数据有误，返回默认固定手数保命
   if (loss_per_lot <= 0) return FixedLot; 

   // --- 第五步：计算原始手数 (Raw Lots) ---
   // 公式：总风险金额 / 1手亏损额 = 需要开的手数
   // 例如：想亏 $100 / 1手亏 $500 = 0.2 手
   double raw_lots = risk_money / loss_per_lot;

   // --- 第六步：手数标准化 (Normalization) ---
   // 获取平台规定的最小手数步长 (例如 0.01 或 0.1)
   double step = MarketInfo(Symbol(), MODE_LOTSTEP);
   // 向下取整逻辑：先除以步长取整，再乘回步长
   // 例如：计算出 0.238 手，步长 0.01 -> 23.8 -> floor(23) -> 0.23 手
   // 这样可以去除多余的小数位，防止下单失败
   raw_lots = MathFloor(raw_lots / step) * step; 

   // --- 第七步：边界检查 (Min/Max Check) ---
   double min = MarketInfo(Symbol(), MODE_MINLOT);
   double max = MarketInfo(Symbol(), MODE_MAXLOT);
   
   // 不能小于平台最小手数
   if (raw_lots < min) raw_lots = min; 
   // 不能大于平台最大手数
   if (raw_lots > max) raw_lots = max;
   
   // 返回最终计算出的、合规的手数
   return raw_lots;
}
********************************************************************************************************************************************************
//+------------------------------------------------------------------+
//| 🛡️ 交易执行函数：计算盈亏比、仓位并下单
//+------------------------------------------------------------------+
void ExecuteTrade(int op_type, int sig_bar, int sl_bar, double sl_price)
{
   // --- 1. 确定入场价格与图表颜色 ---
   // 如果是买单(OP_BUY)，入场价为卖一价(Ask)；卖单(OP_SELL)则为买一价(Bid)
   double entry = (op_type == OP_BUY) ? Ask : Bid;
   // 设置图表上开仓箭头的颜色：买蓝、卖红
   color clr = (op_type == OP_BUY) ? clrBlue : clrRed;

   // --- 2. 止损逻辑安全检查 (Sanity Check) ---
   // 防御性编程：防止因为价格剧烈波动或逻辑错误导致的无效止损
   // 做多时，止损价必须低于入场价
   if (op_type == OP_BUY && sl_price >= entry) { Alert("止损错误：多单止损在现价上方"); return; }
   // 做空时，止损价必须高于入场价
   if (op_type == OP_SELL && sl_price <= entry) { Alert("止损错误：空单止损在现价下方"); return; }
   
   // --- 3. 计算止盈目标 (Take Profit) ---
   // 计算入场价与止损价的物理距离 (价格差)
   double dist = MathAbs(entry - sl_price);
   // 根据设定的盈亏比 (RewardRatio，例如 1.5) 计算止盈价
   // 多单 TP = 入场 + (止损距离 * 1.5)
   // 空单 TP = 入场 - (止损距离 * 1.5)
   double tp_price = (op_type == OP_BUY) ? (entry + dist * RewardRatio) : (entry - dist * RewardRatio);
   
   // --- 4. 仓位管理 (Position Sizing) ---
   double lots = FixedLot; // 默认使用固定手数

   // 如果启用了"基于风险计算手数"模式 (POS_RISK_BASED)
   if (Position_Mode == POS_RISK_BASED) {
      // A. 确定愿意亏损的总金额 (Risk Capital)
      // 如果是固定金额模式，直接取 Risk_Value (如 $100)
      // 如果是百分比模式，取账户余额 * 百分比 (如 $10000 * 1% = $100)
      double risk_money = (Risk_Mode == RISK_FIXED_MONEY) ? 
                          Risk_Value : AccountBalance() * Risk_Value / 100.0;
      
      // B. 获取市场价值参数
      // TickValue: 1 手合约波动 1 个 Point 的价值 (例如黄金通常是 $1 或 $10)
      double tick_val = MarketInfo(Symbol(), MODE_TICKVALUE);
      
      // C. 计算单手预期亏损 (Loss Per Lot)
      // 公式: (止损距离 / 最小跳动单位) * 单点价值
      // 结果: 如果开 1 手，打到止损会亏多少钱
      double loss_per_lot = (dist / Point) * tick_val;
      
      // D. 反推手数 (Risk Calculation)
      // 公式: 总风险金 / 单手亏损额 = 应开手数
      if(loss_per_lot > 0) lots = risk_money / loss_per_lot;
      
      // E. 手数规范化 (Normalization) - 非常关键！
      // 获取平台允许的最小手数步长 (例如 0.01)
      double step = MarketInfo(Symbol(), MODE_LOTSTEP);
      // 向下取整逻辑：确保手数符合平台步长 (例如算出 0.128 -> 变成 0.12)
      lots = MathFloor(lots / step) * step;
      
      // F. 边界检查
      // 确保不小于平台最小开仓手数
      double min = MarketInfo(Symbol(), MODE_MINLOT);
      if(lots < min) lots = min;
      // (通常还应检查最大手数，这里省略了)
   }
   
   // --- 5. 构建订单注释 (Trade Comment) ---
   // 格式示例: "SyncK:1_SL:15" 
   // 含义: 信号在1根K线前，止损锚点在15根K线前。这对复盘非常有用。
   string comm = StringFormat("SyncK:%d_SL:%d", sig_bar, sl_bar);

   // --- 6. 发送交易指令 (OrderSend) ---
   // 核心下单函数
   int ticket = OrderSend(Symbol(), op_type, lots, entry, Slippage, sl_price, tp_price, comm, 0, 0, clr);
   
   // --- 7. 结果反馈 ---
   if(ticket > 0) 
      Print("开仓成功 Ticket: ", ticket); // 下单成功，打印票号
   else 
      Alert("开仓失败 Error: ", GetLastError()); // 失败报警，显示错误代码
}
